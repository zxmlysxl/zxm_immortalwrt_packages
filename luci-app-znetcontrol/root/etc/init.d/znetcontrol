#!/bin/sh /etc/rc.common
#
# ZNetControl init.d脚本 - 修复数字错误版

START=99
USE_PROCD=1

NAME=znetcontrol
PROG=/usr/bin/znetcontrolctrl
PIDFILE="/var/run/${NAME}.pid"
LOGFILE="/var/log/${NAME}.log"
RUNDIR="/var/run/znetcontrol"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') $@" >> "$LOGFILE"
}

validate_service() {
    # 修复：使用正确的数字处理方法
    local enabled_count=0
    
    # 方法1：使用 uci 命令
    if [ -f "/etc/config/znetcontrol" ]; then
        # 修复：避免空值
        enabled_count=$(uci show znetcontrol 2>/dev/null | grep -c '\.enable="1"' 2>/dev/null || echo "0")
        
        # 确保是数字
        enabled_count=$(echo "$enabled_count" | grep -E '^[0-9]+$' || echo "0")
    fi
    
    if [ "$enabled_count" -eq 0 ] 2>/dev/null; then
        echo "没有启用规则，不启动服务"
        return 1
    fi
    
    # 检查必要的工具
    if ! command -v nft >/dev/null 2>&1; then
        echo "nftables 未安装"
        return 1
    fi
    
    return 0
}

pre_start_cleanup() {
    echo "启动前清理..."
    
    # 清理旧的 nftables 表
    local tables
    tables=$(nft list tables 2>/dev/null | awk '{print $2}' 2>/dev/null)
    
    for table in $tables; do
        if echo "$table" | grep -q "znetcontrol"; then
            echo "清理表: $table"
            nft delete table "$table" 2>/dev/null || true
        fi
    done
    
    # 清理旧文件
    rm -rf "$RUNDIR" 2>/dev/null
    mkdir -p "$RUNDIR"
    
    # 初始化防火墙规则
    echo "初始化防火墙规则..."
    if /usr/bin/znetcontrol start >/tmp/znetcontrol_start.log 2>&1; then
        echo "防火墙规则初始化成功"
        return 0
    else
        echo "防火墙规则初始化失败"
        cat /tmp/znetcontrol_start.log 2>/dev/null || true
        return 1
    fi
}

post_stop_cleanup() {
    echo "停止后清理..."
    
    # 清理 nftables 表
    local tables
    tables=$(nft list tables 2>/dev/null | awk '{print $2}' 2>/dev/null)
    
    for table in $tables; do
        if echo "$table" | grep -q "znetcontrol"; then
            echo "删除表: $table"
            nft delete table "$table" 2>/dev/null || true
        fi
    done
    
    # 清理文件
    rm -rf "$RUNDIR" 2>/dev/null
    
    echo "清理完成"
}

start_service() {
    echo "启动 $NAME 服务..."
    
    # 前置检查
    if ! validate_service; then
        echo "服务验证失败，跳过启动"
        return 0  # 返回 0 而不是 1，避免 procd 认为失败
    fi
    
    # 启动前清理
    if ! pre_start_cleanup; then
        echo "启动前清理失败"
        return 1
    fi
    
    # 配置 procd
    procd_open_instance
    procd_set_param command "$PROG"
    
    # 配置 respawn
    procd_set_param respawn
    procd_set_param respawn_retry 3600
    
    # 配置环境变量
    procd_set_param env ZNETCONTROL_DEBUG=0
    
    # 配置 PID 文件
    procd_set_param pidfile "$PIDFILE"
    
    # 配置标准输出
    procd_set_param stdout 1
    procd_set_param stderr 1
    
    # 配置文件变化时触发重载
    procd_set_param file /etc/config/znetcontrol
    
    # 配置用户/组
    procd_set_param user root
    procd_set_param group root
    
    procd_close_instance
    
    echo "服务配置完成"

    # ========== 新增：等待2秒让服务启动，然后显示状态 ==========
    sleep 2
    echo ""
    echo "服务状态："
    /usr/bin/znetcontrol status
}

stop_service() {
    echo "停止 $NAME 服务..."
    
    # 先尝试优雅停止
    if [ -f "$PIDFILE" ]; then
        local pid
        pid=$(cat "$PIDFILE" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            kill -TERM "$pid" 2>/dev/null
            sleep 2
        fi
    fi
    
    # 停止后清理
    post_stop_cleanup
    
    # 确保进程停止
    pkill -f "znetcontrolctrl" 2>/dev/null
    sleep 1
}

reload_service() {
    echo "重新加载配置..."
    
    if [ -f "$PIDFILE" ]; then
        local pid
        pid=$(cat "$PIDFILE" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            # 通知进程重新加载配置
            kill -HUP "$pid" 2>/dev/null && echo "已发送重载信号"
            
            # 重新初始化防火墙规则
            /usr/bin/znetcontrol start
            return 0
        fi
    fi
    
    echo "进程未运行，执行重启..."
    restart
}

service_triggers() {
    procd_add_reload_trigger "znetcontrol"
}

